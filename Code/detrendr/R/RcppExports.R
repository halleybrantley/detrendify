# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @useDynLib detrendr
#' @importFrom Rcpp evalCpp
#' 
#' @title
#' \code{prox_quantile} computes the proximal mapping of the check function.
#'
#' @param w input
#' @param tau quantile parameter
#' @param alpha scale parameter
#' @examples
#' set.seed(12345)
#' n <- 1e3
#' w <- seq(-3, 3, length.out=n)
#' tau <- 0.5
#' alpha <- 2
#' prox_out <- prox_quantile(w, tau, alpha)
#' plot(w, prox_out, type='l', main=expression(paste(tau," = ")))
#'
#' tau <- 0.05
#' alpha <- 2
#' prox_out <- prox_quantile(w, tau, alpha)
#' plot(w, prox_out, type='l', main=expression(paste(tau," = ")))
#' @export
prox_quantile <- function(w, tau, alpha) {
    .Call('detrendr_prox_quantile', PACKAGE = 'detrendr', w, tau, alpha)
}

#' @title
#' Proximal mapping of f_1
#' 
#' \code{prox_f1} computes the proximal mapping of the average quantile loss
#'
#' @param theta input
#' @param y response
#' @param tau quantile parameter
#' @param step step-size
#' @examples
#' @export
prox_f1 <- function(theta, y, tau = 0.05, step = 1.0) {
    .Call('detrendr_prox_f1', PACKAGE = 'detrendr', theta, y, tau, step)
}

#' @title
#' Proximal mapping of f_2
#' 
#' \code{prox_f2} computes the proximal mapping of the L1 penalty
#' 
#' @param eta input
#' @param lambda regularization parameter
#' @param step step-size
#' @export
#' @examples
#' set.seed(12345)
#' n <- 1e3
#' eta <- seq(-3, 3, length.out=n)
#' lambda <- 1
#' prox_out <- prox_f2(eta, lambda)
#' plot(eta, prox_out, type = 'l')
#' abline(0,1)
prox_f2 <- function(eta, lambda, step = 1) {
    .Call('detrendr_prox_f2', PACKAGE = 'detrendr', eta, lambda, step)
}

#' @title
#' Proximal mapping
#' 
#' \code{prox} computes the block separable proximal mapping, changes theta
#' and eta in place
#' @param theta input
#' @param eta input
#' @param y response
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @export 
prox <- function(theta, eta, y, lambda, tau = 0.05, step = 1.0) {
    invisible(.Call('detrendr_prox', PACKAGE = 'detrendr', theta, eta, y, lambda, tau, step))
}

#' @title
#' Proximal Mapping Test
#' 
#' \code{prox_test} computes the block separable proximal mapping.
#' Returns values of theta and eta. 
#' @param theta input
#' @param eta input
#' @param y response
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @export 
prox_test <- function(theta, eta, y, lambda, tau = 0.05, step = 1.0) {
    .Call('detrendr_prox_test', PACKAGE = 'detrendr', theta, eta, y, lambda, tau, step)
}

#' @title Discrete derivative matrix
#' 
#' \code{get_D1} computes the sparse discrete derivative matrix.
#' 
#' @param n length of input
#' @examples
#' n <- 5
#' D1 <- get_D1(n)
#' @export
get_D1 <- function(n) {
    .Call('detrendr_get_D1', PACKAGE = 'detrendr', n)
}

#' @title
#' kth order sparse difference matrix
#' 
#' \code{get_Dkn} computes the sparse discrete kth derivative matrix
#' 
#' @param n length of input
#' @param k order of the derivative
#' @export
get_Dk <- function(n, k) {
    .Call('detrendr_get_Dk', PACKAGE = 'detrendr', n, k)
}

#' @title 
#' Project onto subspace (updates values of theta and eta in place)
#' 
#' \code{project_V} projects (theta, eta) onto the subspace eta = D%*%theta
#' 
#' @param theta first input
#' @param eta second input
#' @param D differencing matrix
#' @param cholM upper triangular cholesky decomposition of  I + DtD
#' @export
project_V <- function(theta, eta, D, cholM) {
    invisible(.Call('detrendr_project_V', PACKAGE = 'detrendr', theta, eta, D, cholM))
}

#' @title
#' One step of Spingarn's algorithm
#' 
#' \code{spingarn_one_step} updates theta and eta in place
#' @param theta input 1
#' @param eta input 2
#' @param y response
#' @param D differencing matrix
#' @param cholM upper cholesky of  (I + DtD)
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @export
spingarn_one_step <- function(theta, eta, y, D, cholM, lambda, tau = 0.05, step = 1) {
    invisible(.Call('detrendr_spingarn_one_step', PACKAGE = 'detrendr', theta, eta, y, D, cholM, lambda, tau, step))
}

#' @title
#' Multiple steps of Spingarn's algorithm
#' 
#' \code{spingarn_one_step}
#' @param theta input 1
#' @param eta input 2
#' @param y response
#' @param k order of derivative 
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @param numberIter number of iterations
#' @export
#' @examples
#' set.seed(12345)
#' n <- 4e3
#' x <- seq(1/n, 1, length.out=n)
#' f <- 2*(x + 2)^2 + 3*cos(3*pi*x)
#' tau <- 5e4
#' g1 <- 40*exp(-tau*(x-0.3)^2)
#' g2 <- 30*exp(-3*tau*(x-0.5)^2)
#' g3 <- 37*exp(-tau*(x-0.7)^2)
#' g4 <- 45*exp(-tau/10*(x-0.55)^2)
#' y <- f + g1 + g2 + g3 + g4 + rnorm(n)
#' plot(y~x, type="l")
#' k <- 3
#' D <- get_Dk(n, k)
#' M <- diag(n) + crossprod(D)
#' cholM <- as.matrix(chol(M))
#' lambda <- 10
#' tau <- 0.01
#' step <- 1
#' numberIter <- 100
#' multi_step <- spingarn_multi_iter(theta, eta, y, n, k, lambda, 
#' tau, step, numberIter)
#' theta <- multi_step[[1]]
#' theta_last <- prox_f1(theta, y, tau)
#' plot(x,f,type='l',col='blue', ylim=c(min(y),max(y)), lwd=3)
#' points(x,y,pch=16)
#' lines(x,theta_last,col='red', lwd=3)
spingarn_multi_step <- function(theta, eta, y, D, cholM, lambda, tau = 0.05, step = 1, numberIter = 1) {
    .Call('detrendr_spingarn_multi_step', PACKAGE = 'detrendr', theta, eta, y, D, cholM, lambda, tau, step, numberIter)
}

